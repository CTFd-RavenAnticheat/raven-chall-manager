{
  "swagger": "2.0",
  "info": {
    "title": "api/v1/challenge/challenge.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "ChallengeStore"
    },
    {
      "name": "SecretManager"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/api/v1/challenge": {
      "get": {
        "summary": "Query all challenges information and their instances running.",
        "operationId": "ChallengeStore_QueryChallenge",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/challengeChallenge"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of challengeChallenge"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "ChallengeStore"
        ]
      },
      "post": {
        "summary": "Before spinning up instances of a challenge, you need to register it.\nThat is the goal of CreateChallenge.\nIf will perform validation on your inputs and especially on the scenario.",
        "operationId": "ChallengeStore_CreateChallenge",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/challengeChallenge"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "The request to create a challenge.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/challengeCreateChallengeRequest"
            }
          }
        ],
        "tags": [
          "ChallengeStore"
        ]
      }
    },
    "/api/v1/challenge/{id}": {
      "get": {
        "summary": "Once saved, you can retrieve the challenge information.\nIf it has not been created yet, returns an error.\nIf the challenge has instances running, returns their information too.",
        "operationId": "ChallengeStore_RetrieveChallenge",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/challengeChallenge"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "The challenge identifier.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "ChallengeStore"
        ]
      },
      "delete": {
        "summary": "At the end of its life, a challenge can be deleted.\nIf it has running instances, it will spin them down.",
        "operationId": "ChallengeStore_DeleteChallenge",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {}
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "The challenge identifier.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "ChallengeStore"
        ]
      },
      "patch": {
        "summary": "A challenge can evolve through time, and on live.\nThe goal of UpdateChallenge is to handle those evolves.\nIf the until changes, sets it up to running instances.\nIf the timeout changes, set running instances until to the last renewal increased by\nthe new timeout.\nIf the scenario changes, update the running instances, but even if this is\ntechnically possible we do not recommend it has we do not look for infrastructure\ndrift.",
        "operationId": "ChallengeStore_UpdateChallenge",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/challengeChallenge"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "The challenge identifier.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ChallengeStoreUpdateChallengeBody"
            }
          }
        ],
        "tags": [
          "ChallengeStore"
        ]
      }
    },
    "/api/v1/scenarios/push": {
      "post": {
        "summary": "Push a scenario to an OCI registry.\nThis endpoint receives a ZIP file containing the scenario and pushes it to the specified registry.",
        "operationId": "SecretManager_PushScenario",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/challengePushScenarioResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "Request to push a scenario to an OCI registry.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/challengePushScenarioRequest"
            }
          }
        ],
        "tags": [
          "SecretManager"
        ]
      }
    },
    "/api/v1/secrets": {
      "get": {
        "summary": "List all secrets in the challenge namespace.",
        "operationId": "SecretManager_ListSecrets",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/challengeListSecretsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace to list secrets from. Defaults to the challenge namespace.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "SecretManager"
        ]
      }
    },
    "/api/v1/secrets/docker-registry": {
      "post": {
        "summary": "Create a Docker registry secret for pulling images from private registries.",
        "operationId": "SecretManager_CreateDockerRegistrySecret",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/challengeSecret"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "Request to create a Docker registry secret.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/challengeCreateDockerRegistrySecretRequest"
            }
          }
        ],
        "tags": [
          "SecretManager"
        ]
      }
    },
    "/api/v1/secrets/generic": {
      "post": {
        "summary": "Create a generic opaque secret for configuration data.",
        "operationId": "SecretManager_CreateGenericSecret",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/challengeSecret"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "Request to create a generic opaque secret.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/challengeCreateGenericSecretRequest"
            }
          }
        ],
        "tags": [
          "SecretManager"
        ]
      }
    },
    "/api/v1/secrets/test-registry": {
      "post": {
        "summary": "Test registry credentials without creating a secret.",
        "operationId": "SecretManager_TestRegistryConnection",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/challengeTestRegistryConnectionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "Request to test registry credentials.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/challengeTestRegistryConnectionRequest"
            }
          }
        ],
        "tags": [
          "SecretManager"
        ]
      }
    },
    "/api/v1/secrets/tls": {
      "post": {
        "summary": "Create a TLS secret for HTTPS ingress.",
        "operationId": "SecretManager_CreateTLSSecret",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/challengeSecret"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "Request to create a TLS secret.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/challengeCreateTLSSecretRequest"
            }
          }
        ],
        "tags": [
          "SecretManager"
        ]
      }
    },
    "/api/v1/secrets/{name}": {
      "delete": {
        "summary": "Delete a secret from the challenge namespace.",
        "operationId": "SecretManager_DeleteSecret",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {}
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "name",
            "description": "The secret name.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "description": "The namespace where the secret is stored. Defaults to chall-manager.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "SecretManager"
        ]
      }
    }
  },
  "definitions": {
    "ChallengeStoreUpdateChallengeBody": {
      "type": "object",
      "properties": {
        "scenario": {
          "type": "string",
          "example": "registry.lan/category/challenge-scenario:v0.1.0@sha256:a0b1...c2d3",
          "description": "The OCI reference to get the deployment scenario from, i.e. the Pulumi\ninfrastructure factory.\nExtracted files are the ones with metadata `application/vnd.ctfer-io.file`.\nIf specified, will updates running instances if the old and new tag and/or\ndigests differs.\n\nTo ensure stability through deployments, we highly recommend you pin\nthe tag and the digest."
        },
        "updateStrategy": {
          "$ref": "#/definitions/challengeUpdateStrategy",
          "description": "If specified, sets the update strategy to adopt in case the challenge has running\ninstances.\nDefault to an update in place."
        },
        "timeout": {
          "type": "string",
          "description": "The timeout after which the janitor will have permission to delete the instances."
        },
        "until": {
          "type": "string",
          "format": "date-time",
          "description": "The date after which the janitor will have permission to delete the instances."
        },
        "updateMask": {
          "type": "string"
        },
        "additional": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "A key=value additional configuration to pass to the instance when created."
        },
        "min": {
          "type": "string",
          "format": "int64",
          "example": 1,
          "description": "Min from the pooler feature.\nDetermine the minimum number of instances we want to pre-provision, and make\navailable for claiming later."
        },
        "max": {
          "type": "string",
          "format": "int64",
          "example": 1,
          "description": "Max from the pooler feature.\nDetermine the maximum number of instances that needs to be deployed until we\nstop pre-provisioning ones in the pool."
        },
        "imagePullSecrets": {
          "type": "array",
          "example": "gitlab-group-1",
          "items": {
            "type": "string"
          },
          "description": "Image pull secrets to use when pulling container images for this challenge.\nThese secrets must exist in the challenge-manager namespace."
        }
      },
      "description": "The request to update a challenge."
    },
    "challengeChallenge": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "example": 1,
          "description": "The challenge identifier."
        },
        "scenario": {
          "type": "string",
          "example": "registry.lan/category/challenge-scenario:v0.1.0@sha256:a0b1...c2d3",
          "description": "The OCI reference to get the deployment scenario from, i.e. the Pulumi\ninfrastructure factory."
        },
        "timeout": {
          "type": "string",
          "description": "The timeout after which the janitor will have permission to delete\nthe instances."
        },
        "until": {
          "type": "string",
          "format": "date-time",
          "description": "The date after which the janitor will have permission to delete\nthe instances."
        },
        "instances": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/instanceInstance"
          },
          "description": "The challenge running instances."
        },
        "additional": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "A key=value additional configuration to pass to the instance when created."
        },
        "min": {
          "type": "string",
          "format": "int64",
          "example": 1,
          "description": "Min from the pooler feature.\nDetermine the minimum number of instances we want to pre-provision, and make\navailable for claiming later."
        },
        "max": {
          "type": "string",
          "format": "int64",
          "example": 1,
          "description": "Max from the pooler feature.\nDetermine the maximum number of instances that needs to be deployed until we\nstop pre-provisioning ones in the pool."
        },
        "imagePullSecrets": {
          "type": "array",
          "example": "gitlab-group-1",
          "items": {
            "type": "string"
          },
          "description": "Image pull secrets to use when pulling container images for this challenge.\nThese secrets must exist in the challenge-manager namespace."
        }
      },
      "description": "The challenge object that the chall-manager exposes.\nNotice it differs from the internal representation, as it also handles\nfilesystem-related information.",
      "required": [
        "id",
        "scenario"
      ]
    },
    "challengeCreateChallengeRequest": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "example": 1,
          "description": "The challenge identifier."
        },
        "scenario": {
          "type": "string",
          "example": "registry.lan/category/challenge-scenario:v0.1.0@sha256:a0b1...c2d3",
          "description": "The OCI reference to get the deployment scenario from, i.e. the Pulumi\ninfrastructure factory.\nExtracted files are the ones with metadata `application/vnd.ctfer-io.file`.\n\nTo ensure stability through deployments, we highly recommend you pin\nthe tag and the digest."
        },
        "timeout": {
          "type": "string",
          "description": "The timeout after which the janitor will have permission to delete the instance."
        },
        "until": {
          "type": "string",
          "format": "date-time",
          "description": "The date after which the janitor will have permission to delete the instance."
        },
        "additional": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "A key=value additional configuration to pass to the instance when created."
        },
        "min": {
          "type": "string",
          "format": "int64",
          "example": 1,
          "description": "Min from the pooler feature.\nDetermine the minimum number of instances we want to pre-provision, and make\navailable for claiming later."
        },
        "max": {
          "type": "string",
          "format": "int64",
          "example": 1,
          "description": "Max from the pooler feature.\nDetermine the maximum number of instances that needs to be deployed until we\nstop pre-provisioning ones in the pool."
        },
        "imagePullSecrets": {
          "type": "array",
          "example": "gitlab-group-1",
          "items": {
            "type": "string"
          },
          "description": "Image pull secrets to use when pulling container images for this challenge.\nThese secrets must exist in the challenge-manager namespace.\nMultiple challenges can share the same secret(s)."
        }
      },
      "description": "The request to create a challenge.",
      "required": [
        "id",
        "scenario"
      ]
    },
    "challengeCreateDockerRegistrySecretRequest": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "example": "gitlab-registry",
          "description": "The secret name."
        },
        "namespace": {
          "type": "string",
          "example": "chall-manager",
          "description": "The namespace to create the secret in. Defaults to chall-manager."
        },
        "server": {
          "type": "string",
          "example": "registry.gitlab.com",
          "description": "The registry server URL."
        },
        "username": {
          "type": "string",
          "example": "my-username",
          "description": "The registry username."
        },
        "password": {
          "type": "string",
          "example": "glpat-xxx",
          "description": "The registry password or token."
        },
        "email": {
          "type": "string",
          "example": "user@example.com",
          "description": "The email associated with the registry account."
        }
      },
      "description": "Request to create a Docker registry secret.",
      "required": [
        "name",
        "server",
        "username",
        "password"
      ]
    },
    "challengeCreateGenericSecretRequest": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "example": "challenge-flags",
          "description": "The secret name."
        },
        "namespace": {
          "type": "string",
          "example": "chall-manager",
          "description": "The namespace to create the secret in. Defaults to chall-manager."
        },
        "data": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "The key-value data to store in the secret."
        }
      },
      "description": "Request to create a generic opaque secret.",
      "required": [
        "name",
        "data"
      ]
    },
    "challengeCreateTLSSecretRequest": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "example": "challenge-tls",
          "description": "The secret name."
        },
        "namespace": {
          "type": "string",
          "example": "chall-manager",
          "description": "The namespace to create the secret in. Defaults to chall-manager."
        },
        "cert": {
          "type": "string",
          "example": "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----",
          "description": "The TLS certificate in PEM format."
        },
        "key": {
          "type": "string",
          "example": "-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----",
          "description": "The TLS private key in PEM format."
        }
      },
      "description": "Request to create a TLS secret.",
      "required": [
        "name",
        "cert",
        "key"
      ]
    },
    "challengeListSecretsResponse": {
      "type": "object",
      "properties": {
        "secrets": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/challengeSecret"
          },
          "description": "The list of secrets."
        }
      },
      "description": "Response containing the list of secrets."
    },
    "challengePushScenarioRequest": {
      "type": "object",
      "properties": {
        "scenarioZip": {
          "type": "string",
          "format": "byte",
          "title": "The scenario files as a ZIP archive.\nThe ZIP should contain Pulumi.yaml, __main__.py, and requirements.txt"
        },
        "reference": {
          "type": "string",
          "example": "registry.lan/category/challenge:v1.0.0",
          "description": "The OCI reference to push to (e.g., \"registry.lan/category/challenge:v1.0.0\").\nUses the globally configured OCI registry credentials (OCI_USERNAME, OCI_PASSWORD)."
        }
      },
      "description": "Request to push a scenario to an OCI registry.",
      "required": [
        "scenarioZip",
        "reference"
      ]
    },
    "challengePushScenarioResponse": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean",
          "description": "Whether the push was successful."
        },
        "reference": {
          "type": "string",
          "example": "registry.lan/category/challenge:v1.0.0",
          "description": "The scenario reference that was pushed."
        },
        "digest": {
          "type": "string",
          "example": "sha256:a0b1c2d3...",
          "description": "The digest of the pushed scenario."
        },
        "message": {
          "type": "string",
          "description": "A message describing the result."
        }
      },
      "description": "Response from pushing a scenario to a registry."
    },
    "challengeSecret": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "example": "gitlab-registry",
          "description": "The secret name."
        },
        "type": {
          "type": "string",
          "example": "kubernetes.io/dockerconfigjson",
          "description": "The secret type (e.g., kubernetes.io/dockerconfigjson, Opaque, kubernetes.io/tls)."
        },
        "namespace": {
          "type": "string",
          "example": "chall-manager",
          "description": "The namespace where the secret is stored."
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "The creation timestamp.",
          "readOnly": true
        },
        "dataKeys": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The keys stored in the secret.",
          "readOnly": true
        },
        "usedByChallenges": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of challenge IDs that use this secret.",
          "readOnly": true
        }
      },
      "description": "A Kubernetes secret representation.",
      "required": [
        "name",
        "type",
        "namespace"
      ]
    },
    "challengeTestRegistryConnectionRequest": {
      "type": "object",
      "properties": {
        "server": {
          "type": "string",
          "example": "registry.gitlab.com",
          "description": "The registry server URL."
        },
        "username": {
          "type": "string",
          "example": "my-username",
          "description": "The registry username."
        },
        "password": {
          "type": "string",
          "example": "glpat-xxx",
          "description": "The registry password or token."
        }
      },
      "description": "Request to test registry credentials.",
      "required": [
        "server",
        "username",
        "password"
      ]
    },
    "challengeTestRegistryConnectionResponse": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean",
          "description": "Whether the connection was successful."
        },
        "message": {
          "type": "string",
          "description": "A message describing the result."
        },
        "authenticated": {
          "type": "boolean",
          "description": "Whether authentication was successful."
        }
      },
      "description": "Response from testing registry credentials."
    },
    "challengeUpdateStrategy": {
      "type": "string",
      "enum": [
        "update_in_place",
        "blue_green",
        "recreate"
      ],
      "default": "update_in_place",
      "description": "The UpdateStrategy to use in case of a Challenge scenario update with running instances.\nDefault strategy is the update-in-place.\n\n - update_in_place: update_in_place updates the existing state based on the new stack in the scenario.\nThis update strategy provide high availability with low update costs.\n - blue_green: blue_green spins up a second instance of the scenario in parallel and once up,\ndelete the previous one for players to shift.\nThis update strategy provide high availability with high update costs due to infra\ndeduplication.\n - recreate: recreate delete the previous instance then spins up a fresh instance of the scenario.\nThis update strategy provide no availability guarantee with medium update costs due\nto intensive create/delete operations. It should be used at a last relief, for\ninstance if the update is inconsistent and the outcomes are not predictable."
    },
    "instanceInstance": {
      "type": "object",
      "properties": {
        "challengeId": {
          "type": "string",
          "example": 1,
          "title": "The challenge identifier"
        },
        "sourceId": {
          "type": "string",
          "example": 1,
          "description": "The source (user/team) identifier."
        },
        "since": {
          "type": "string",
          "format": "date-time",
          "example": 1,
          "description": "The time since when the instance is running."
        },
        "lastRenew": {
          "type": "string",
          "format": "date-time",
          "example": 1,
          "description": "The last time the instance has been renewed."
        },
        "until": {
          "type": "string",
          "format": "date-time",
          "example": 1,
          "description": "The time the instance will \"die\" i.e. be destroyed by the janitor."
        },
        "connectionInfo": {
          "type": "string",
          "example": 1,
          "description": "The connection information that is given to the players in order\nto reach their instance."
        },
        "flag": {
          "type": "string",
          "example": 1,
          "description": "If specified, the flag that validates the challenge instance.\nThis avoids shareflag, but don't block sharing solving strategy/write-up.\nDEPRECATED: #950 showed the need for multiple flags, so please migrate to it."
        },
        "flags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of flags that validates the challenge instance.\nThis avoids shareflag, but don't block sharing solving strategy/write-up."
        },
        "additional": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "A key=value additional configuration to pass to the instance when created."
        }
      },
      "description": "The challenge instance object that the chall-manager exposes.\nNotice it differs from the internal representation, as it handles\nfilesystem-related information.",
      "required": [
        "challengeId",
        "sourceId",
        "since",
        "lastRenew",
        "connectionInfo"
      ]
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "additionalProperties": {}
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    }
  }
}
